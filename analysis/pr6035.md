# PR 6035 Issue

The PR introduces new `paletteOnly` logic in `src/components/color-control/index.js`. Inside the added `useEffect` hooks, it calls `onChange({ paletteStatus: true })` and `onChange({ paletteSCStatus: true })` when `paletteOnly` is enabled:

```
useEffect(() => {
        if (paletteOnly && !paletteStatus) {
                onChange({
                        paletteStatus: true,
                });
        }
}, [paletteOnly]);

useEffect(() => {
        if (paletteOnly && globalStatus && !paletteSCStatus) {
                onChange({
                        paletteSCStatus: true,
                });
        }
}, [paletteOnly, globalStatus]);
```

However, `ColorControl` receives its `onChange` prop from `BorderColorControl`, which destructures all colour-related values and forwards them to `setAttributes`. When `onChange` is invoked with only `paletteStatus` or `paletteSCStatus`, all other destructured values (`paletteColor`, `paletteOpacity`, `color`) become `undefined`. This causes existing border colours and palette assignments to be wiped whenever `paletteOnly` becomes true.

To keep the other values intact, the effects should use the existing `onChangeValue` helper (which merges the new values with the current `colorObj`) or call `onChange` with the full payload. As it stands, enabling `paletteOnly` erases the saved colour configuration.


